<script src="script/at-doc-parser.js"></script>
<link rel="import" href="../at-core-activity/at-core-activity.html">

<dom-module id="at-doc-parser">
  <style>

  </style>
  <template>
    <at-core-activity id="loader" url={{url}} auto="true" handle-as="text"></at-core-activity>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-doc-parser',
      properties: {
        url: {
          type: String,
          value: ''
        },
        value: {
          type: Object,
          value: ''
        }
      },
      _scopeCssViaAttr: true,
      ready: function() {
        var loader = this.$.loader;
        var url = this.url;
        var self = this;

        loader.addEventListener('response', function(event) {
          var text = event.detail;

          if (text) {

            var elementName = '';
            // determine element name
            if (this.url.indexOf('/') === -1) {
              // url is of format at-*-*.html
              // strip .html
              elementName = this.url.replace('.html', '');
            } else {
              // url is of format ../at-*-*/at-*-*.html
              // split for '/'
              var parts = this.url.split('/');
              var part = parts[1];
              elementName = part;
            }

            self.importHref(self.url, function(event) {
              var element = document.createElement(elementName);
              // we need this to find out the function names
              var elementProto = element.__proto__;
              var entity = {
                name: elementName,
                description: '',
                properties: [],
                methods: [],
                events: []
              };
              var properties = element.properties;
              Object.keys(properties).forEach(function(propName, index) {
                var propDef = properties[propName];
                var docProperty = self._constructDocProperty(propName, propDef);
                entity.properties.push(docProperty);
              });

              // to figure out stuff from comments behavior should be importHref'ed
              // the trouble is how to figure out behavior name, and how to know what url to target

              // figure out properties in behaviors
              if (self.isArray(element.behaviors)) {
                var bi;
                var bLen = element.behaviors.length;
                var behavior;
                var bProperties;
                var bPropertyNames;
                var propDef;
                for (bi = 0; bi < bLen; bi += 1) {
                  behavior = element.behaviors[bi];
                  bProperties = behavior.properties;
                  bPropertyNames = Object.keys(bProperties);
                  bPropertyNames.forEach(function(propName, index) {
                    propDef = bProperties[propName];
                    var docProperty = self._constructDocProperty(propName, propDef);
                    entity.properties.push(docProperty);
                  });
                }
              }

              var entities = DocParser.parse(text, entity);
              if (!entities || entities.length === 0) {
                entities = [{
                  name: url.split('/').pop(),
                  description: '**Undocumented**'
                }];
              }
              self.value = entities;
              entities[0].properties.sort(function (item1, item2) {
                var i1Upper = item1.name.toUpperCase();
                var i2Upper = item2.name.toUpperCase();
                if ( i1Upper > i2Upper) {
                  return 1;
                } else if (i1Upper < i2Upper){
                  return -1
                }
                return 0;
              });
              self.fire('value-changed', {
                value: self.value
              });

            }, function(event) {
              // error; do nothing
            });

          }
        });
      },
      _constructDocProperty: function(propName, propDef) {
        var type = 'object';
        var self = this;
        if (propDef.type) {
          var type = typeof propDef.type();
        } else {
          console.log('Can not determine the type of ' + propDef.type + '.');
          console.log('Using type object instead.');
        }
        var defValue = propDef.value;
        if (self.isFunction(propDef.value)) {
          defValue = propDef.value();
          if (self.isObject(defValue)) {
            defValue = JSON.stringify(defValue);
          }
        } else if (defValue === '') {
          defValue = 'empty';
        } else if (self.isObject(propDef.value)) {
          defValue = JSON.stringify(propDef.value);
        }
        var isEnum = propDef.xtype && propDef.xtype === 'enum' && propDef.xvaluelist;
        var possibleValues = false;
        if (isEnum) {
          possibleValues = self._constructPossibleValuesString(propDef.xvaluelist);
        }

        var docProperty = {
          name: propName,
          description: '',
          type: type,
          default: defValue,
          possibleValues: possibleValues
        };
        return docProperty;
      },
      _constructPossibleValuesString: function(xvaluelist) {
        // xvaluelist can be CSV string, array of strings and array of {title, value} objects
        // array of {title, value} objects doesn't make sense for documentation so it will be ignored
        var result = false;
        var partsArr;
        var self = this;

        if (this.isCSVString(xvaluelist)) {
          partsArr = xvaluelist.split(',');
        } else if (this.isArray(xvaluelist)) {
          partsArr = xvaluelist;
        }

        var partsArrLength = partsArr.length;
        if (partsArrLength > 0) {
          result = '';
        }
        partsArr.forEach(function(part, index) {
          if (self.isString(part)) {
            result = result + '' + part;
            if (index < partsArrLength - 1) {
              result = result + ', ';
            }
          }
        });

        return result;
      },
      isObject: function(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
      },
      isString: function(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      },
      isCSVString: function(obj) {
        return Object.prototype.toString.call(obj) === "[object String]" && obj.indexOf(',') !== -1;
      },
      isArray: function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      },
      isFunction: function(obj) {
        return Object.prototype.toString.apply(obj) === "[object Function]";
      }
    });
  </script>
</dom-module>
